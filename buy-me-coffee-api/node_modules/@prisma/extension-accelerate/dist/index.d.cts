import * as PrismaDefault from '@prisma/client/scripts/default-index.js';
import PrismaDefault__default, { Prisma } from '@prisma/client/scripts/default-index.js';
import { Types } from '@prisma/client/runtime/library.js';
import * as _prisma_client_runtime_library from '@prisma/client/runtime/library';

declare const FETCH_FAILURE_MESSAGE = "Unable to connect to the Accelerate API. This may be due to a network or DNS issue. Please check your connection and the Accelerate connection string. For details, visit https://www.prisma.io/docs/accelerate/troubleshoot.";
interface PrismaCacheStrategy {
    /**
     * Specifies the caching parameters for Accelerate.
     *
     * `cacheStrategy` only applies when used with an Accelerate connection string.
     */
    readonly cacheStrategy?: {
        /**
         * `swr` is short for Stale-While-Revalidate.
         *
         * `swr` defines the number of seconds that Accelerate may serve _stale_ cache data.
         * _Stale_ data is a cache hit, but the cache will be refreshed in the background by Accelerate.
         * The Prisma operation will not be blocked while data is refreshed.
         *
         * Use `swr` to reduce the latency of accessing the data while still maintaining
         * a more up-to-date value in the Accelerate cache.
         * `swr` without `ttl` will not reduce database load since Accelerate will
         * run the query in the background.
         *
         * `swr` can be combined with `ttl`.
         * `swr` applies **after** `ttl` has expired.
         * The total number of seconds data will be cached is `ttl + swr`.
         *
         * `swr` only applies when used with an Accelerate connection string.
         */
        readonly swr?: number;
        /**
         * `ttl` is short for Time-to-Live.
         *
         * `ttl` defines the number of seconds that Accelerate may serve _fresh_ cache data.
         * _Fresh_ data is a cache hit and will not execute the query against the database.
         *
         * Use `ttl` to reduce database load and latency for data that does not
         * require frequent updates.
         * `ttl` without `swr` will incur a blocking database query for the first
         * request after `ttl` expires.
         *
         * It's recommended to combine `ttl` and `swr` to maintain low latency while
         * Accelerate refreshes cached data in the background.
         * `swr` applies **after** `ttl` has expired.
         * The total number of seconds data will be cached is `ttl + swr`.
         *
         * `ttl` only applies when used with an Accelerate connection string.
         */
        readonly ttl?: number;
        /**
         * `tags` allow you to attach string values to the query's cache entry
         * that can later be used to invalidate the cache.
         *
         * A tag may only contain alphanumeric characters and underscores.
         * Each tag may contain a maximum of 64 characters.
         * A maximum of 5 tags are allowed per query.
         */
        readonly tags?: ReadonlyArray<string>;
    };
}
type PrismaFetch = (url: string, options: {
    body?: string;
    method?: string;
    headers: Record<string, string>;
}) => Promise<Response>;
interface AccelerateInfo {
    /**
     * The cache status of the response.
     * * `ttl` indicates a cache hit within the `ttl` duration and no database query was executed
     * * `swr` indicates a cache hit within the `swr` duration and the data is being refreshed by Accelerate in the background
     * * `miss` indicates that both `ttl` and `swr` have expired and the database query was executed by the request
     * * `none` indicates that no cache strategy was specified and the database query was executed by the request
     */
    cacheStatus: "ttl" | "swr" | "miss" | "none";
    /**
     * The date the response was last refreshed.
     */
    lastModified: Date;
    /**
     * The datacenter region that received the request.
     */
    region: string;
    /**
     * Unique identifier of the request. Useful for troubleshooting.
     */
    requestId: string;
    /**
     * The unique signature of the Prisma operation.
     */
    signature: string;
}
type AccelerateInvalidateInput = {
    /** Invalidate cache by tags set in the query `cacheStrategy`. */
    tags: ReadonlyArray<string>;
};
interface AcceleratePromise<T> extends Prisma.PrismaPromise<T> {
    withAccelerateInfo(): Prisma.PrismaPromise<{
        data: T;
        info: AccelerateInfo | null;
    }>;
}
declare function makeAccelerateExtension(fetcher: PrismaFetch): (client: any) => PrismaDefault__default.PrismaClientExtends<Types.Extensions.InternalArgs<{}, {
    $allModels: {
        aggregate<T, A>(this: T, args: Prisma.Exact<A, Prisma.Args<T, "aggregate"> & PrismaCacheStrategy>): AcceleratePromise<Prisma.Result<T, A, "aggregate">>;
        count<T, A>(this: T, args?: Prisma.Exact<A, Prisma.Args<T, "count"> & PrismaCacheStrategy>): AcceleratePromise<Prisma.Result<T, A, "count">>;
        findFirst<T, A>(this: T, args?: Prisma.Exact<A, Prisma.Args<T, "findFirst"> & PrismaCacheStrategy>): AcceleratePromise<Prisma.Result<T, A, "findFirst"> | null>;
        findFirstOrThrow<T, A>(this: T, args?: Prisma.Exact<A, Prisma.Args<T, "findFirstOrThrow"> & PrismaCacheStrategy>): AcceleratePromise<Prisma.Result<T, A, "findFirstOrThrow">>;
        findMany<T, A>(this: T, args?: Prisma.Exact<A, Prisma.Args<T, "findMany"> & PrismaCacheStrategy>): AcceleratePromise<Prisma.Result<T, A, "findMany">>;
        findUnique<T, A>(this: T, args: Prisma.Exact<A, Prisma.Args<T, "findUnique"> & PrismaCacheStrategy>): AcceleratePromise<Prisma.Result<T, A, "findUnique"> | null>;
        findUniqueOrThrow<T, A>(this: T, args: Prisma.Exact<A, Prisma.Args<T, "findUniqueOrThrow"> & PrismaCacheStrategy>): AcceleratePromise<Prisma.Result<T, A, "findUniqueOrThrow">>;
        groupBy<T, A>(this: T, args: Prisma.Exact<A, Prisma.Args<T, "groupBy"> & PrismaCacheStrategy>): AcceleratePromise<Prisma.Result<T, A, "groupBy">>;
    };
}, {}, {
    $accelerate: {
        /**
         * Initiates an invalidation request for the specified cache tag values.
         *
         * A tag may only contain alphanumeric characters and underscores.
         * Each tag may contain a maximum of 64 characters.
         * A maximum of 5 tags may be invalidated per call.
         */
        invalidate: (input: AccelerateInvalidateInput) => Promise<{
            requestId: string;
        }>;
        /**
         * Initiates an invalidation request of all cache entries for this
         * environment.
         */
        invalidateAll: () => Promise<{
            requestId: string;
        }>;
    };
}> & Types.Extensions.InternalArgs<{}, {}, {}, {}> & Types.Extensions.DefaultArgs>;

interface WithAccelerateOptions {
    fetch?(this: void, input: RequestInfo | URL, init?: RequestInit): Promise<Response>;
}
declare function withAccelerate(options?: WithAccelerateOptions): (client: any) => PrismaDefault.PrismaClientExtends<_prisma_client_runtime_library.InternalArgs<{}, {
    $allModels: {
        aggregate<T, A>(this: T, args: _prisma_client_runtime_library.Exact<A, _prisma_client_runtime_library.Args<T, "aggregate"> & PrismaCacheStrategy>): AcceleratePromise<_prisma_client_runtime_library.Result<T, A, "aggregate">>;
        count<T, A>(this: T, args?: _prisma_client_runtime_library.Exact<A, _prisma_client_runtime_library.Args<T, "count"> & PrismaCacheStrategy>): AcceleratePromise<_prisma_client_runtime_library.Result<T, A, "count">>;
        findFirst<T, A>(this: T, args?: _prisma_client_runtime_library.Exact<A, _prisma_client_runtime_library.Args<T, "findFirst"> & PrismaCacheStrategy>): AcceleratePromise<_prisma_client_runtime_library.Result<T, A, "findFirst"> | null>;
        findFirstOrThrow<T, A>(this: T, args?: _prisma_client_runtime_library.Exact<A, _prisma_client_runtime_library.Args<T, "findFirstOrThrow"> & PrismaCacheStrategy>): AcceleratePromise<_prisma_client_runtime_library.Result<T, A, "findFirstOrThrow">>;
        findMany<T, A>(this: T, args?: _prisma_client_runtime_library.Exact<A, _prisma_client_runtime_library.Args<T, "findMany"> & PrismaCacheStrategy>): AcceleratePromise<_prisma_client_runtime_library.Result<T, A, "findMany">>;
        findUnique<T, A>(this: T, args: _prisma_client_runtime_library.Exact<A, _prisma_client_runtime_library.Args<T, "findUnique"> & PrismaCacheStrategy>): AcceleratePromise<_prisma_client_runtime_library.Result<T, A, "findUnique"> | null>;
        findUniqueOrThrow<T, A>(this: T, args: _prisma_client_runtime_library.Exact<A, _prisma_client_runtime_library.Args<T, "findUniqueOrThrow"> & PrismaCacheStrategy>): AcceleratePromise<_prisma_client_runtime_library.Result<T, A, "findUniqueOrThrow">>;
        groupBy<T, A>(this: T, args: _prisma_client_runtime_library.Exact<A, _prisma_client_runtime_library.Args<T, "groupBy"> & PrismaCacheStrategy>): AcceleratePromise<_prisma_client_runtime_library.Result<T, A, "groupBy">>;
    };
}, {}, {
    $accelerate: {
        invalidate: (input: AccelerateInvalidateInput) => Promise<{
            requestId: string;
        }>;
        invalidateAll: () => Promise<{
            requestId: string;
        }>;
    };
}> & _prisma_client_runtime_library.InternalArgs<{}, {}, {}, {}> & _prisma_client_runtime_library.DefaultArgs>;

export { type AccelerateInfo, type AccelerateInvalidateInput, type AcceleratePromise, FETCH_FAILURE_MESSAGE, type PrismaCacheStrategy, type WithAccelerateOptions, makeAccelerateExtension, withAccelerate };
